// 首先每个引用都有生命周期,也就是引用保持有效的作用域
// 一个引用的作用域从声明的地方开始一直持续到最后一次使用为止

// 函数或方法的参数的生命周期被称为 输入生命周期,而返回值的生命周期被称为 输出生命周期
// 隐式生命周期,官方介绍了3条规则
// 1. 每一个是引用的参数都有它自己的生命周期参数
// 2. 如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数
// 3. 如果方法有多个输入生命周期参数并且其中一个参数是 &self 或 &mut self，那么所有输出生命周期参数被赋予 self 的生命周期

// 生命周期语法是用于将函数的多个参数与其返回值的生命周期进行关联的。一旦他们形成了某种关联，
// Rust 就有了足够的信息来允许内存安全的操作并阻止会产生悬垂指针亦或是违反内存安全的行为

// 静态生命周期 'static 其生命周期能够存活于整个程序期间
// 不过将引用指定为 'static 之前，思考一下这个引用是否真的在整个程序的生命周期里都有效。
// 你也许要考虑是否希望它存在得这么久，即使这是可能的。大部分情况，代码中的问题是尝试创建
// 一个悬垂引用或者可用的生命周期不匹配，请解决这些问题而不是指定一个 'static 的生命周期

// 白话说就是 它是否真的可以存活整个程序期间,不是靠 'static, 而是这个引用是否真实可以存活
// 前面提到:生命周期声明类似于变量类型声明，不会改变对象的真正生命周期,所以’'static’只是告诉编译器而已
// 所有的字符串字面值(&str)都拥有 'static 生命周期

// 生命周期声明是入参和返回值或者结构体成员之间的一种生命周期约定和限制

// 这个函数会报错,具体原因我们后面会讲到 missing lifetime specifier
// consider introducing a named lifetime parameter
// 可以理解成随机返回 x 或 y,因为在运行时2种情况都会出现
// 返回值是 &T(&String) 类型,编译器要知道它是从哪借来的，因为编译器要确定
// 返回值的生命周期——简单说就是编译器要知道返回值什么时候被释放，防止乱用
// 编译器告诉我们返回类型需要一个泛型生命周期参数因为编译器不能推断出
// 返回值的生命周期是指向x的生命周期还是y的生命周期

// fn longest(x: &String, y: &String) -> &String {
//     if x.len() > y.len() {
//         x
//     } else {
//         y
//     }
// }

// 生命周期声明类似于变量类型声明，不会改变对象的真正生命周期。
// 当你生命的生命周期和实际不符合的时候，编译器会报错。
// Rust生命周期标注，仅仅是告诉编译器变量的生命周期是什么样的，并不会真正改变变量的生命周期
// 单一生命周期标注，如果作为输入参数，返回值的实际生命周期由生命周期较短者决定
// 增加泛型生命周期参数来定义引用间的关系以便借用检查器可以进行分析
// 当具体的引用被传递给 longest 时，被 'a 所替代的具体生命周期是 x 的作用域与 y 的作用域相重叠的那一部分
fn longest1<'a>(x: &'a String, y: &'a String) -> &'a String {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

// 例如在上述longest例子中，当编译器看到 x: &'a str的时候，'a 会被编译器推断为x的生命周期
// 当编译器看到 y: &'a str 的时候，编译器会将 'a 推断为y的生命周期，但是此时有冲突，
// 于是编译器会将 'a 推断为x和y的生命周期中最小的那个

// 我们为参数 x 和返回值指定了生命周期参数 'a，不过没有为参数 y 指定，
// 因为 y 的生命周期与参数 x 和返回值的生命周期没有任何关系, 能够编译通过
fn longest2<'a>(x: &'a str, y: &str) -> &'a str {
    x
}

// fn longest3<'a, 'b>(x: &'a str, y: &'b str) -> &'a str {
//     if x.len() > y.len() {
//         x
//     } else {
//         y
//     }
// }

// 上述函数声明了'a和'b生命周期参数，分别对应x和y的生命周期。
// 函数返回值声明只会用x的生命周期。但是编译器发现函数可能返回y，于是编译器会报错

// 当从函数返回一个引用，返回值的生命周期参数需要与一个参数的生命周期参数相匹配。
// 如果返回的引用 没有 指向任何一个参数，那么唯一的可能就是它指向一个函数内部创建的值
// 然而它将会是一个悬垂引用，因为它将会在函数结束时离开作用域。
// 尝试考虑这个并不能编译的 longest 函数实现
// fn longest4<'a>(x: &str, y: &str) -> &'a str {
//     let result = String::from("really long string");
//     result.as_str()
// }

struct ABC<'a> {
    field1: &'a i32,
}
impl<'a> ABC<'a> {
    fn f1(x: &'a i32) {}
    fn f2(&self, x: &'a i32) {}
}

struct ABC1<'a> {
    // 一样
    field1: &'a i32,
    field2: &'a i32,
}

struct ABC2<'a, 'b> {
    // 不一样
    field1: &'a i32,
    field2: &'b i32,
}

fn main() {
    let a = String::from("a");
    let c;
    {
        let b = String::from("bob");
        // 我们并不知道它会返回a还是b,这导致生命周期的不确定性
        // 那么此时c就是不安全的,你不敢在大括号外使用c
        // c = longest(&a, &b);

        c = longest1(&a, &b);
    } // b 在这里就死了

    // 这行会报错,因为最小生命周期是 b
    // println!("b: {}", b);
}
