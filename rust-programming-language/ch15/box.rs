// 最简单直接的智能指针是 box，其类型是 Box<T>。box 允许你将一个值放在堆上而不是栈上。留在栈上的则是指向堆数据的指针。

// 除了数据被储存在堆上而不是栈上之外，box 没有性能损失。不过也没有很多额外的功能。它们多用于如下场景：
// 当有一个在编译时未知大小的类型，而又想要在需要确切大小的上下文中使用这个类型值的时候
// 当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候
// 当希望拥有一个值并只关心它的类型是否实现了特定 trait 而不是其具体类型的时候

// 现在我们知道了任何 List 值最多需要一个 i32 加上 box 指针数据的大小。通过使用 box，打破了这无限递归的连锁
// 这样编译器就能够计算出储存 List 值需要的大小了

// 实现 Deref trait 允许我们重载 解引用运算符（dereference operator）*（不要与乘法运算符或通配符相混淆）。
// 通过这种方式实现 Deref trait 的智能指针可以被当作常规引用来对待，可以编写操作引用的代码并用于智能指针。

enum List {
    Cons(i32, Box<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}
