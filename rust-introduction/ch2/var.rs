// Rust中变量赋值操作实际上是Rust中的一种模式匹配

fn main() {
    // Rust会对未使用的变量发出警告信息。如果确实想保留从未被使用过的变量，可在变量名前加上_前缀
    let gender = "male"; // 警告，gender未使用
    let _age = 18; // 加_前缀的变量不被警告

    // Rust允许声明未被初始化(即未被赋值)的变量，但不允许使用未被赋值的变量。多数情况下，都是声明的时候直接初始化的
    // 只声明，未初始化
    let name;
    // 取消该行注释，将编译错误
    // println!("{}", name);

    name = "example.com";
    println!("{}", name);
    // 变量默认不可变
    // name = "test";

    // Rust允许重复声明同名变量，后声明的变量将遮盖(shadow)前面已声明的变量。
    // 需注意的是，遮盖不是覆盖，被遮盖的变量仍然存在，而如果是被覆盖则不再存在
    // (也即，覆盖时，原数据会被销毁)
    let name = "alice";

    // 推导结果：变量 s1 为 &str 数据类型
    let mut s1 = "alice";
    s1 = "bob";

    // Rust不仅对未被使用过的变量发出警告，还对赋值过但未被使用过的值发出警告。
    // 比如变量赋值后，尚未读取该变量，就重新赋值了
    let mut name = "example.com"; // 警告值未被使用过
    name = "example1.com";
    println!("{}", name);

    // 明确指定age为i32类型
    let age: i32 = 32;
    println!("{}", name);

    // i32类型的变量想存储u8类型数据，不允许
    // age = 23_u8;

    // 虽然Rust是基于表达式的语言，但变量声明的let代码是语句而非表达式。
    // 这意味着let操作没有返回值，因此无法使用let来连续赋值
    // let a = (let b = 1);  // 错误

    // 可以使用tuple的方式同时为多个变量赋值，并且可以使用下划线_占位表示忽略某个变量的赋值过程
    // x = 11, y = 22, 忽略33
    let (x, y, _) = (11, 22, 33);

    // 事实上，_占位符比想象中还更会【偷懒】，其他语言中_表达的含义可能是丢弃其赋值结果(甚至不丢弃)
    // 但Rust中的_会直接忽略变量赋值的过程。这导致了这样一种看似奇怪的现象：
    // 使用普通变量名会导致报错的变量赋值行为，使用_却不会报错

    let s1 = "example.com".to_string();
    let _ = s1;
    println!("{}", s1); // 不会报错

    // (2)
    let s2 = "example.com".to_string();
    let ss = s2;
    // println!("{}", s2); // 报错, s2 的所有权转移到 ss
}
