// 引用类型是一种数据类型，它表示其所保存的值是一个引用
// 引用，通常来说是指向其他数据的一个指针或一个胖指针(有额外元数据的指针)
// 例如&33表示的是一个指向数据值33的一个指针

#![allow(unused)]
fn main() {
    let n: &i32 = &33_i32;

    // 可以将保存了引用的变量赋值给其他变量，这样就有多个变量拥有同一份数据的引用
    let n = 33;
    let n_ref1 = &n; // n_ref1指向33
    let n_ref2 = n_ref1; // n_ref2也指向33

    // 可以使用std::ptr::eq()来判断两个引用是否指向同一个地址
    // 即判断所指向的数据是否是同一份数据
    println!("{}", std::ptr::eq(n_ref1, n_ref2)); // true

    // 如果想要通过引用去修改源数据，需要使用&mut v来创建可修改源数据v的可变引用
    // 想要通过&mut引用去修改源数据，要求原变量是可变的
    // let n = 33;
    // let n_ref = &mut n;   // 编译错误

    let mut n1 = 33;
    let n_ref = &mut n1;
    *n_ref = 32;
    assert_eq!(*n_ref, 32);
    n1 = *n_ref - 2;
    assert_eq!(n1, 30);

    // 解引用表示解除引用，即通过引用获取到该引用所指向的原始值。
    // 解引用使用*T表示
    let s = String::from("alice");
    let s_ref = &s; // s_ref 是指向 "alice" 的一个引用

    // *s_ref 表示通过引用 s_ref 获取其指向的 "alice"
    // 因此 s 和 *s_ref 都指向同一个 "alice"，它们是同一个东西
    assert_eq!(s, *s_ref); // true
}

// Rust绝大多数时候不会自动地解除引用。但在某些环境下，Rust会自动进行解引用。
// 自动解引用的情况有
// (1) 使用.操作符时(包括取属性值和方法调用)，会隐式地尽可能解除或创建多层引用
// (2) 使用比较操作符时，若比较的两边是相同类型的引用，则会自动解除引用到它们的值然后比较
