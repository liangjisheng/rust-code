// 在Rust中，任何一个可用来包含代码的大括号都是一个单独的作用域
// 类似于Struct{}这样用来定义数据类型的大括号，不在该讨论范围之内
// 可以单独使用一个大括号来开启一个作用域

// Rust的编译器保证永远不会出现悬垂引用：引用必须总是有效。
// 即引用必须在数据被销毁之前先失效，而不能销毁数据后仍继续持有该数据的引用

fn s1() {
    {
        // s 在这里无效, 它尚未声明
        let s = "hello"; // 从此处起，s是有效的
        println!("{}", s); // 使用 s
        println!("{:p}", s); // 0x109fb1c30
    } // 此作用域已结束，s不再有效

    // 变量s失效，变量s所绑定的值会自动被销毁
    // 实际上，变量跳出作用域失效时，会自动调用Drop Trait的drop函数来销毁该变量绑定在内存中的数据，
    // 这里特指销毁堆和栈上的数据，而字符串字面量是存放在全局内存中的，
    // 它会在程序启动到程序终止期间一直存在，不会被销毁
    let s = "hello";
    println!("{:p}", s); // 0x109fb1c30

    // 上面的示例中只是让变量s失效了，仅此而已，并没有销毁s所绑定的字符串字面量
    // 但一般情况下不考虑这些细节，而是照常描述为【跳出作用域时，会自动销毁变量所绑定的值】
}

fn s2() {
    // 任意大括号之间都可以嵌套。例如可以在函数定义的内部再定义函数，
    // 在函数内部使用单独的大括号，在函数内部使用mod定义模块
    fn ff() {
        println!("hello world");
    }
    ff();

    let mut a = 33;
    {
        a += 1;
    }
    println!("{}", a); // 34
}

fn s3() {
    // 虽然任何一种大括号都有自己的作用域，但函数作用域比较特别。
    // 函数作用域内，无法访问函数外部的变量，而其他大括号的作用域，可以访问大括号外部的变量
    let x = 32;
    fn f() {
        // 编译错误，不能访问函数外面的变量x和y
        // println!("{}, {}", x, y);
    }
    let y = 33;
    f();

    let mut a = 33;
    {
        // 可以访问大括号外面的变量a
        a += 1;
    }
    println!("{}", a);

    // 在Rust中，能否访问外部变量称为【捕获环境】。比如函数是不能捕获环境的，而大括号可以捕获环境
}

fn main() {
    // s1();
    s2();
    s3();
}
