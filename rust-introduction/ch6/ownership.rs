// Rust中的每个值都有一个被称为其所有者的变量(即：值的所有者是某个变量)
// 值在任一时刻有且只有一个所有者
// 当所有者(变量)离开作用域，这个值将被销毁

// 多数人可能会误以为变量s是堆中字符串数据hello的所有者，但实际上不是
// String字符串的实际数据在堆中，但是String大小不确定，所以在栈中使用一个
// 胖指针结构来表示这个String类型的数据，这个胖指针中的指针指向堆中的String实际数据
// 也就是说，变量s的值是那个胖指针，而不是堆中的实际数据。
// 因此，变量s是那个胖指针的所有者，而不是堆中实际数据的所有者
// 但是，由于胖指针是指向堆中数据的，多数时候为了简化理解简化描述方式，
// 也经常会说s是那个堆中实际数据的所有者。但无论如何描述，需要理解所有者和值之间的真相

#![allow(unused)]
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;

    // Rust采用非常直接的方式，当执行let s2 = s1;时，直接让s1无效
    // (s1仍然存在，只是变成未初始化变量，Rust不允许使用未初始化变量，可重新为其赋值)
    // 而是只让s2绑定堆内存的数据。也就是将s1移动到s2，也称为值的所有权从s1移给s2

    // Rust还有Copy语义，和Move语义几乎相同，唯一的区别是Copy后，原始变量仍然可用
    // 前面说过，Move实际上是进行了拷贝(栈中的数据)，只不过拷贝后让原始变量变回未初始化状态了
    // 而Copy的行为，就是保留原始变量

    // 但Rust默认是使用Move语义，如果想要使用Copy语义，要求要拷贝的数据类型实现了Copy Trait
    // 例如，i32默认就已经实现了Copy Trait，因此它在进行所有权转移的时候，会自动使用Copy语义，而不是Move语义

    // 对于那些没有实现Copy的自定义类型，可以手动去实现Copy(要求同时实现Clone)
    let x = Xyz(11, 22);
    let y = x;
    // println!("x: {}", x); // 报错
    println!("y: {:?}", y);

    let d = Def(33, 44);
    let e = d;
    println!("d: {:?}", d);
    println!("e: {:?}", e);

    let vb0 = vec!["s1".to_string()];
    let v = vec![vb0];
    println!("{:p}", &v[0][0]);

    let vc = v.clone();
    println!("{:p}", &vc[0][0]);
    // 2次打印出来的地址是不一样的，说明发生了堆上的数据也复制了
}

#[derive(Debug)]
struct Xyz(i32, i32);

#[derive(Copy, Clone, Debug)]
struct Def(i32, i32);

// 但不是所有数据类型都可以进行克隆，只有那些实现了Clone Trait的类型才可以进行克隆
// 对于那些没有实现Clone Trait的自定义类型，需要手动实现Clone Trait。在自定义类型之前加上#[derive(Clone)]即可

// 要注意Copy和Clone时的区别，如果不考虑自己实现Copy trait和Clone trait，而是使用它们的默认实现，那么：
// Copy时，只拷贝变量本身的值，如果这个变量指向了其它数据，则不会拷贝其指向的数据
// Clone时，拷贝变量本身的值，如果这个变量指向了其它数据，则也会拷贝其指向的数据
// 也就是说，Copy是浅拷贝，Clone是深拷贝，Rust会对每个字段每个元素递归调用clone()，直到最底部

// 函数参数类似于变量赋值，在调用函数时，会将所有权移动给函数参数
// 函数返回时，返回值的所有权从函数内移动到函数外变量
