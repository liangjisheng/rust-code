// 不可变引用可以共存，表示允许同时有多个不可变引用来访问数据
// 可变引用具有排他性，某数据在某一时刻只允许有一个可变引用，此时不允许有其他任何引用

// 对某个位置每建立一次引用就记录一次，如果是建立共享引用，则简单判断即可，
// 但对该位置进行可变引用之后，从此刻开始的任意时刻，这个位置将只能存在单一使用者，
// 使用者可以是原始变量，可以是新的可变引用或不可变引用，使用者可以随时更换，
// 但保证任意时刻只能有一个使用者

fn r1() {
    let mut x = String::from("alice");
    let _x1 = &x;
    let _x2 = &x;
    let _x3 = &x;

    let x_mut1 = &mut x; // (1)
    let x_mut2 = &mut x; // (2)

    // error
    // println!("{}", x_mut1); // (3)
    println!("{}", x_mut2); // (4)

    // 去掉上面的代码(3)或者同时去掉代码(3)和(4)
    // 又或者将代码(3)移到代码(2)之前，得到的代码都是可以正确执行的代码
}

fn r2() {
    // 可以将可变引用看作是一把独占锁。在当前作用域内，从第一次使用可变引用开始创建这把独占锁，
    // 之后无论使用原始变量(即所有权拥有者)、可变引用还是不可变引用都会抢占这把独占锁，
    // 以保证只有一方可以访问数据，每次抢得独占锁后，都会将之前所有引用变量给锁住，
    // 使它们变成不可用状态。当离开当前作用域时，当前作用域内的所有独占锁都被释放。
    // 因此，可变引用是抢占且排他的，将其称为抢占式独占锁更为合适。
    // 换个角度来理解，自从第一次使用可变引用导致独占锁出现后，可以随时使用原始变量、
    // 可变引用或不可变引用来抢独占锁，但抢锁后以前的引用变量就不能再用，且当前持有的锁也可以随时被抢走
    // 一切都由程序员控制，程序员可以在任意代码位置通过原始变量或引用来抢锁

    let mut a = String::from("alice");

    // 创建两个不可变引用，不可变引用可以共存
    // 此时还没有独占锁
    let a_non_ref1 = &a;
    let a_non_ref2 = &a;
    // 可直接使用不可变引用
    println!("{}", a_non_ref1);
    println!("{}", a_non_ref2);

    // 第一次使用可变引用，将出现独占锁，a_ref1拥有独占锁
    let a_ref1 = &mut a;
    // 抢占独占锁后，前面两个不可变引用变量将不能使用
    // 因此下面两行代码报错
    // println!("{}", a_non_ref1);
    // println!("{}", a_non_ref2);

    // 再次使用不可变引用，a_non_ref3将获得独占锁
    let a_non_ref3 = &a;
    // 抢占独占锁后，前面所有引用变量都不能使用
    // 因此下面代码会报错
    // println!("{}", a_ref1);
    // println!("{}", a_non_ref1);

    // 再次使用可变引用，a_ref2将获得独占锁
    // 抢占后前面所有该数据的引用都不可用
    let a_ref2 = &mut a;
    // 但a_ref2是可用的
    println!("{}", a_ref2);

    // 这里println!中使用的是a的不可变引用&a，
    // 但不可变引用也会抢占独占锁，前面所有引用变量将不能使用
    println!("{}", a);
    // 因此下面的代码会报错
    // println!("{}", a_ref2);

    let a_ref3 = &a;
    println!("{}", a_ref3);

    // 任何时候使用原始变量a，也会抢占独占锁
    a = String::from("alice");
    // error a 重新赋值后, 前面所有的引用都不能用
    // println!("{}", a_ref3);
}

fn r3() {
    let mut x = String::from("alice");
    let x3 = &mut x; // x3抢占独占锁
    ff(&x); // &x抢占独占锁，参数s获得锁，使得x3不可用

    // println!("{}", x3); // 使用了x3，导致报错，注释本行将正确
}

fn ff(s: &String) {
    println!("{}", s);
}

fn r4() {
    let mut x = Box::new(42); // 1

    // 创建x的可变引用
    let mut z = &x; // 2

    // 在考虑引用检查问题和生命周期问题时，循环结构for {} 和多个独立的大括号 {} 是等价的
    for i in 0..2 {
        // 使用可变引用
        println!("{}", z); // 3

        // 抢占x的独占锁，使得z不再可用
        // 第一轮循环时创建x的独占锁
        x = Box::new(i); // 4

        // 因此下面的代码会报错
        // println!("{}", z);

        // 虽然z不可用，但z自身可以被重新赋值，重新赋值将丢弃z之前对x的引用，
        // 注意这里使用了x的可变引用，它会抢占x的独占锁，
        // 虽然这里z重新引用了x，但和赋值之前引用的x已经不一样，它是一个新的引用，
        // 并且z在这里抢占到了新的x独占锁，而赋值之前的x独占锁已经被代码行4抢占
        z = &x; // 5
    }
}

fn r5() {
    let mut x = 33;
    let y = &mut x; // y获得独占锁
    *y = 2;
    println!("{}", y); // 2
    println!("{}", *y); // 2

    x = *y + 1; // 使用y获取数据后，x重新抢得独占锁

    // 赋值之后，x有效，y将失效
    println!("{}", x); // 正确

    // x 重新赋值后, 之前的所有引用都失效了
    // println!("{}", y); // 错误
}

fn main() {
    // r1();
    // r2();
    // r3();
    // r4();
    r5();
}
